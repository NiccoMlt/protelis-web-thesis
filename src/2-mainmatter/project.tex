\chapter{Analisi del problema \& Progettazione}\label{ch:project}
  Una volta chiariti i requisiti del sistema, il passo successivo riguarda la progettazione dello stesso.
  In particolare, occorre delineare più nel dettaglio l'architettura di massima del sistema, per poi spostare l'attenzione su ciascuna entità interagente.

  % \section{Architettura del sistema}
  Come preventivato già in fase di analisi dei requisiti, il sistema vede la presenza di due principali entità:

  \begin{itemize}
    \item una pagina web che costituisce il client del sistema.
    \item un server di backend, che esegue su piattaforma JVM interfacciandosi con un esecutore di codice Protelis.
  \end{itemize}

  \begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\textwidth]{res/uml/architecture-design.eps}%
    \caption{Il diagramma UML riporta l'architettura di massima dei componenti del sistema}%
    \label{fig:architecture-design}
  \end{figure}

  Nelle \nameCrefs{sec:arch:client} successive di questo \nameCref{ch:project}, si intende analizzare più nel dettaglio questa struttura (di cui si ha una rappresentazione grafica in~\Cref{fig:architecture-design}),
  focalizzandosi sui dettagli di ciascun componente.

  \section{Design dell'applicazione}\label{sec:client-design}
    % TODO: inserire breve introduzione sulle GUI

    \subsection{Mockup dell'interfaccia}\label{subsec:mockup}
      Una volta chiariti i requisiti e le possibili fonti di ispirazione per la struttura della GUI da realizzare, sono stati disegnati dei mockup che potessero rappresentare una linea guida
      per l'implementazione concreta dell'interfaccia.

      Come detto anche nella~\Cref{subsec:online-ide}, la struttura grafica dell'applicazione dovrebbe ispirarsi a quella di altri ambienti di sviluppo online,
      come ad esempio Overleaf (\Cref{fig:overleaf}).

      \begin{figure}[htbp]
        \centering
        \includegraphics[width=.85\textwidth]{res/fig/overleaf.png}%
        \caption{Screenshot prelevato dalla pagina principale della web app Overleaf}%
        \label{fig:overleaf}
      \end{figure}

      Tali applicazioni hanno generalmente una struttura bipartita:
      nella parte sinistra è solitamente presente un editor che ricorda quello disponibile in diverse IDE desktop, mentre nella parte destra viene generalmente inserita una visualizzazione dell'output.
      Ad esempio, in Overleaf è possibile, alternativamente, visualizzare il log degli errori o il documento compilato.

      \begin{figure}[htbp]
        \centering
        \includegraphics[width=.85\textwidth]{res/mockup/gui-actual.eps}%
        \caption{Mockup dell'interfaccia che dovrà presentare la pagina web}%
        \label{fig:mockup}
      \end{figure}

      Nel mockup finale, riportato in~\Cref{fig:mockup}, si è preso molto ispirazione da questo tipo di struttura.
      L'interfaccia dovrebbe infatti essere costituita dalle seguenti parti:

      \begin{itemize}
        \item
          Una barra superiore, nella quale è riportato il nome e il logo del progetto, insieme a un selettore per il backend.
          Nei primi mockup, tale selettore era posizionato nella sezione principale della pagina, ma successivamente si è preferito spostarlo per sfruttare al meglio lo spazio a disposizione.
        \item
          Un blocco di sinistra, che costituisce la parte con cui l'utente può interagire per lavorare sul codice.
          Il componente principale è appunto l'editor, un campo di testo ``avanzato'' che permette di visualizzare il codice Protelis di esempio e modificarlo.
          Sotto di esso sono presenti i bottoni di controllo per interagire con l'esecuzione.
        \item
          Un blocco di destra, che ospita un canvas in cui l'esecuzione viene rappresentata.
          Al suo interno, verranno visualizzati i nodi su cui il codice sta eseguendo.
          % In questa sezione, i componenti principali sono:
          % \begin{description}
          %   \item[Editor]
          %     Un campo di testo in cui visualizzare codice Protelis di esempio e modificarlo.
          %   \item[Play]
          %     Un bottone che permette di lanciare l'esecuzione del codice.
          %   % \item[Add]
          %   % TODO
          % \end{description}
      \end{itemize}

    \subsection{Design di riferimento}\label{subsec:material}
      Come è stato già sottolineato, l'applicazione vede come utilizzo principale quello dell'utente inesperto del linguaggio.
      L'interfaccia non deve essere solo semplice, ma anche moderna, gradevole e intuitiva.
      Era dunque necessario scegliere uno stile grafico familiare, moderno e facilmente adattabile a quella che sarebbe essere la nuova interfaccia che si stava progettando.

      Prendendo come esempio l'interfaccia di Overleaf (\Cref{fig:overleaf}), è possibile notare come il design di base abbia uno stile di tipo \emph{flat};
      si è deciso dunque di valutare tra i principali design possibili quali fosse più adeguato per la UX che si aveva intenzione di progettare.

      La scelta è infine ricaduta sul Material Design sviluppato da Google:
      dal suo annuncio nel giugno del 2014 al Google I/O 2014 Keynote esso è stato almeno parzialmente adottato in molte applicazioni web, mobile e desktop
      e ben si si presta all'implementazione di un'interfaccia semplice e minimale. % TODO eventualmente cita evoluzioni successive

      Per offrire un'esperienza coerente, si è deciso di utilizzare le icone e le direttive in merito a dimensioni e variazioni nella palette di colori fornite da Google\footnote{\url{https://material.io}}.
      Il colore base utilizzato per generare la palette è stato ricavato dall'icona ufficiale di Protelis. % TODO: cite logo

  \section{Architettura del client}\label{sec:arch:client}

    L'applicazione web che svolge il ruolo di client è a tutti gli effetti un'applicazione indipendente e dotata di interfaccia grafica.
    % Sono stati valutati i numerosi pattern di modellazione documentati in letteratura e, alla fine,
    Sono numerosi i pattern di modellazione documentati in letteratura.
    % Molti di questi (genericamente definiti ``MV*'', ossia \emph{\emph{M}odel, \emph{V}iew} e qualsiasi cosa, generalmente \emph{Controller} o \emph{ViewModel}) tendono a distinguere entità che modellano il dominio
    % Tra tutti quelli considerati, si è scelto di adottare il \emph{pattern Flux} nella variazione chiamata \emph{pattern Redux}.
    La caratteristica maggiormente ricercata durante la progettazione è la reattività:
    il sistema dovrebbe aggiornarsi rapidamente sia quando l'utente lo richiede, interagendo via browser, sia quando il server manda un aggiornamento.

    % È stato dunque ritenuto necessario scegliere un approccio che ponesse al centro lo \emph{stato} del sistema, per poi scegliere, nella prossima fase, le tecnologie più adatte a reagire rapidamente alle sue variazioni.

    % Nelle \nameCrefs{subsec:state-manage} che seguono verranno prese in considerazione le scelte fatte decidendo il piano di lavoro.

    \subsection{Framework di sviluppo}\label{subsec:react}

      Sono disponibili numerosi framework per lo sviluppo di applicazioni web \emph{single-page}, ciascuna dei quali ottimizzata per determinati pattern di progettazione.
      Essendo un requisito la realizzazione di una SPA, la scelta di quale framework impiegare è fondamentale già in fase di progetto, in quando può notevolmente condizionare il piano di lavoro.

      Per l'implementazione di questo prototipo, è stato scelto il framework React, sviluppato da Facebook e compatibile, ufficialmente o meno, con numerosi linguaggi.
      Tecnicamente React, senza prendere in considerazione gli strumenti sviluppati intorno ad esso, sarebbe una libreria per la costruzione di pagine web reattive e \emph{data-driven};
      esso potrebbe essere considerato, riduttivamente, il \emph{view layer} dei pattern architetturali MV*.
      React non è però vincolato al pattern MVC come AngularJS o a MVVM come Angular dalla versione 2 in poi.

      % In AngularJS, ogni vista è associata ad un controller, che si occupa della gestione dei dati e della loro visualizzazione.
      % La view è definita da un template, formata da elementi HTML, ed è compito dello sviluppatore associare la logica di controllo alla rappresentazione.

      La divisione principale che determina la struttura è quella tra \emph{componenti}.
      In React, un componente è un'astrazione che incapsula i dati, la loro manipolazione e la logica di rappresentazione e va a definire il più piccolo elemento costitutivo dell'applicazione.
      Esso rimuove la necessità del \emph{data-binding} tra modello e vista, tipico dei pattern MV*, e mantiene la logica applicativa all'interno di ciò a cui fa riferimento.

      Un componente definisce insomma cosa deve essere renderizzato;
      il sistema, autonomamente, determina in modo reattivo quando una delle dipendenze è cambiata e il componente può essere singolarmente ridisegnato.

      In questo modo, è possibile costruire applicazioni componendo tra loro questi elementi in una struttura simile a un albero, delegando la logica di gestione al motore di React, che se ne occuperà in modo efficiente.

      La progettazione dell'architettura deve dunque spostarsi sulla gestione dello stato.

      % React, come buona parte dei framework per lo sviluppo di applicazioni web, si basa sul concetto di \emph{componente}.
      %
      % Il successo di React deriva dalla visione innovativa della struttura di un'applicazione web.
      % React non presenta una separazione netta tra gli elementi di vista, presentazione e logica applicativa;

      % non esiste un controller, né data-binding

      % Anziché separare in modo deciso gli elementi di vista dal resto della logica applicativa (come invece accade tramite template e linguaggi di markup in Angular, ad esempio),

      % React incapsula
      % L'approccio tradizionale, adottato ad esempio da Angular, utilizza dei template realizzati tramite linguaggi di markup, dove la vista è realizzata tramite , sul quale vengono fatti

      % React nasce fondamentalmente come risposta al problema del \emph{change detection} che affligge.

      % start TODO
      % È stato dunque ritenuto necessario scegliere un approccio che ponesse al centro lo \emph{stato} del sistema, per poi scegliere, nella prossima fase, le tecnologie più adatte a reagire rapidamente alle sue variazioni.
      % end TODO

    \input{src/2-mainmatter/redux.tex}
      Nel caso di questo progetto, tale soluzione è stata ritenuta ottimale per il tipo di architettura che si intende realizzare.

      \unsure[inline]{
        A mio parere, analizzare Redux e il pattern Flux è \strong{fondamentale} per dare una rappresentazione dettagliata dell'architettura del client.

        Però, non sono sicuro se il posto corretto in cui introdurla sia questo o prima. Nello stato dell'arte \emph{non} mi sembra corretto.
      }

      Prendendo dunque in considerazione il mockup delineato alla~\Cref{subsec:mockup}, lo store sarebbe costituito dalle seguenti parti (dette \emph{slice}):

      \begin{description}
        \item[Editor]
          In \texttt{editorSlice} saranno inserite tutte le informazioni relative allo stato dei file.
          In particolare, è possibile definire al suo interno una struttura ad albero riguardante i file e lo stato di apertura degli stessi.
        \item[Esecuzione]
          In \texttt{execSlice} saranno invece inseriti i dati relativi all'esecuzione, come:
          \begin{itemize}
            \item lo stato della connessione,
            \item lo stato della simulazione,
            \item l'ID della simulazione,
            \item i dati dei nodi da rappresentare.
          \end{itemize}
      \end{description}

  \section{Architettura del server}\label{sec:arch:server}
    % TODO

  \section{Interazioni}
