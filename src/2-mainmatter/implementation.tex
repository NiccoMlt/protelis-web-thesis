\chapter{Implementazione}\label{ch:implementation}
  In questo \nameCref{ch:implementation} sono esposti tutti i dettagli legati al processo di sviluppo e all'implementazione.
  In particolare, per quanto possibile verranno motivate le scelte tecnologiche che in fase di progettazione non erano state considerate rilevanti.
  Inoltre, verranno analizzati alcuni dettagli implementativi ritenuti importanti alla descrizione del funzionamento del progetto.

  \section{Tecnologie utilizzate}

    \subsection{Linguaggi di programmazione}
      Il sistema è stato realizzato in due differenti linguaggi. Di seguito sono espresse le motivazioni della scelta di ciascuno di essi.

      \subsubsection{Linguaggio per il backend: Kotlin}

        Per la realizzazione del backend, come è stato specificato nel~\Cref{ch:requirements}, era necessario l'impiego di un linguaggio in grado di eseguire su piattaforma JVM\@.
        Il framework scelto, Vert.x, è presentato come poliglotta (supporta Java, JavaScript, Groovy, Ruby, Ceylon, Scala e Kotlin) e non vincolava la scelta.

        Si è deciso di procedere con Kotlin per le seguenti motivazioni:

        \begin{description}
          \item[Brevità ed espressività]
            Kotlin si presenta come molto meno verboso di Java, supportando un maggior numero di costrutti che permettono di ridurre il codice ``\emph{boilerplate}''.

          \item[Sicurezza]
            Una delle funzionalità che è stata pubblicizzata maggiormente alla presentazione di Kotlin è la \emph{null-safety}.
            Kotlin permette di evitare le comuni eccezioni di tipo \texttt{NullPointerException} gestendo il valore \texttt{null} in modo maggiormente chiaro tramite notazione opzionale e controllo da parte del compilatore.

          \item[Interoperabilità]
            Kotlin nasce per essere affiancato a Java e sostituirlo gradualmente.
            Risulta dunque intercompatibile con quasi qualsiasi piattaforma o libreria sia pensata per Java, non limitando eventualmente l'affiancamento futuro ad un altro linguaggio.

            Inoltre, il compilatore di Kotlin supporta diversi altri target, come browser, piattaforme mobile e binario nativo X86 e ARM, lasciando dunque aperte ulteriori possibilità di espansione future.

          \item[Approccio funzionale]
            Kotlin è un linguaggio orientato agli oggetti, ma supporta molti costrutti tipici della programmazione funzionale, come espressioni \emph{lambda}, \emph{function types} e le funzioni di ordine superiore.

          % \item[Performance]
            % Kotlin  pone  alcuni  miglioramenti  prestazionali nelle funzioni di ordine superiore e lambda, dimostrandosi più ottimizzato e veloce nei confronti di Java

          \item[Pragmatismo]
            Kotlin presenta, secondo la documentazione, l'intento di essere ``pragmatico'', ossia focalizzato sull'esperienza d'uso dello sviluppatore.
            Esso offre una buona integrazione con gli strumenti esistenti, sia per la costruzione (come Gradle e Maven) che per lo sviluppo (come Eclipse, Visual Studio e gli IDE di JetBrains).
        \end{description}

        Vert.x offre inoltre una estensione della propria libreria \emph{core} per sfruttare al meglio la sintassi di Kotlin.

      \subsubsection{Linguaggio per il frontend: TypeScript}

        Per la realizzazione dell'applicazione web che costituisce il frontend del sistema si è deciso di utilizzare TypeScript.
        Sono stati presi in considerazione tutti i quattro linguaggi introdotti nella~\Cref{sec:lang}, ma si è preferito impiegare TypeScript per i seguenti motivi:

        \begin{description}
          \item[Supporto ufficiale]
            Per quanto React venga presentato anche nella documentazione ufficiale~\cite{react-docs} come non strettamente dipendente dal linguaggio, il supporto disponibile per ciascuno di questi può essere differente.
            In particolare, Facebook, dichiara il supporto diretto solo per JavaScript e TypeScript;
            linguaggi come Kotlin, Scala, Reason e F\# sono dichiaratamente compatibili, ma la loro integrazione non è una priorità per la società.

            Kotlin (attraverso JetBrains) e Scala (attraverso il progetto Scala.js) offrono un supporto comunitario sufficiente, ma comunque non comparabile a quello offerto da Facebook e Microsoft.\unsure{Dovrei citare statistici da GitHub per sostenere questa posizione?}

          \item[Type Checking]
            JavaScript supporta unicamente la tipizzazione dinamica.
            Se questo aspetto da un lato aggiunge flessibilità al linguaggio, dall'altro aumenta la possibilità di bug e situazioni non previste.
            TypeScript offre un sistema di tipi completo e flessibile, che permette di definire una struttura chiara e flessibile, rendendo il processo di sviluppo più sicuro.

            Facebook supporta ufficialmente Flow e la libreria \texttt{prop-types} come alternativa all'utilizzo di un diverso linguaggio.
            Flow non offre però la medesima espressività di TypeScript e non può vantare un supporto altrettanto vasto da parte della comunità per la tipizzazione delle librerie JavaScript.
            La libreria \texttt{prop-types} invece offre un controllo dei tipi unicamente a tempo di esecuzione, richiedendo la definizione del tipo atteso manualmente.
            Questo non permette di adottare un approccio ``\emph{fail-fast}'' come quello vantato da TypeScript.

          \item[Integrazione con gli IDE]
            La possibilità di avere informazione sui tipi a livello di compilatore permettono a IDE come Visual Studio Code e WebStorm di essere molto più precisi ad evidenziare codice errato rispetto all'approccio basato su commenti di JavaScript.

          \item[Estensione della sintassi JSX e TSX]
            Una delle maggiori particolarità del framework React è la sintassi \emph{JSX}\@.
            L'acronimo sta per \emph{\emph{J}ava\emph{S}cript e\emph{X}tension} e identifica un particolare zucchero sintattico non presente in JavaScript ``standard''.
            Esso permette la definizione di ``\texttt{element}'', ossia di componenti direttamente rappresentabili, attraverso una sintassi dichiarativa di markup che ricorda HTML\@. \unsure{Dovrei inserire uno snippet di confronto?}

            Essendo in React la logica rappresentativa strettamente legata agli elementi non grafici del componente, essere in grado di distinguere in modo chiaro i \emph{concetti}\improvement{Non sono sicuro di aver espresso correttamente in italiano ``separation of concerns'', che sarebbe da traduzione separazione di interessi}
            all'interno dello stesso componente e file senza doversi affidare a markup esterno è un vantaggio notevole.

            TypeScript supporta questa estensione della sintassi, denominandola \emph{TSX}.

        \end{description}

        L'unica alternativa presa in considerazione al posto di TypeScript era Kotlin.
        L'impiego di Kotlin per tutta l'applicazione sarebbe stato infatti molto interessante per utilizzare un unico linguaggio in tutto il sistema, migliorando l'integrazione e il supporto a dipendenze condivise.

        Purtroppo, per quanto JetBrains supporti ufficialmente React per Kotlin/JS, l'integrazione all'inizio dei lavori di questa tesi era ancora troppo instabile per un uso reale.
        Si sono riscontrati problemi con lo strumento di generazione dei \emph{wrapper} per i tipi\unsure{Dovrei citare la issue GitHub che avevamo creato?} e l'output del compilatore genera codice JS datato e pesante.
        Fintanto che la versione 1.4 di Kotlin non sarà rilasciata in pianta stabile, si ritiene che il linguaggio non sia ancora pronto per un uso frontend su browser.

    \subsection{Strumenti per lo sviluppo e il controllo del software}
      Per gestire le dipendenze in sistemi moderni, l'uso di applicazioni per la \emph{build-automation} dotati di risoluzione delle dipendenze è l'approccio più comune.

      L'utilizzo di strumenti che controllino la qualità del codice e diano la possibilità di testarlo in modo immediato è invece fondamentale per la realizzazione di un sistema complesso.
      Essi permettono infatti di revisionare il codice in modo sistematico, così da evitare errori che a volte possono verificarsi, senza bisogno che il programma venga realmente eseguito:
      analizzano il codice sorgente per individuare potenziali bug e spesso indicano possibili miglioramenti e ottimizzazioni.
      % Spesso tali strumenti vengono integrati nel processo di costruzione del codice.

      Essendo le due componenti basate su ecosistemi completamente diversi, verranno trattate separatamente.

      \subsubsection{Backend}

        Il backend utilizza Gradle per la risoluzione delle dipendenze, la costruzione del software e la verifica della qualità.
        Gradle è un sistema per l'automazione dello sviluppo, nato per includere tutte le caratteristiche provenienti da Apache Ant, Maven e Ivy attraverso la definizione di \engEmph{buildscript} in Groovy e, più recentemente, in Kotlin.
        Pensato per i linguaggi che compilano per JVM, questo sistema permette di scaricare le dipendenze da diversi repository Maven durante la fase di compilazione.
        Nello script di costruzione sono stati utilizzati i seguenti plugin:

        \begin{description}
          \item[Gradle Shadow]
            Il plugin, sviluppato da John Engelman, permette la generazione di ``shadow jar'', ossia pacchetti jar contenenti anche tutte le dipendenze oltre al codice compilato.

          \item[Vert.x Gradle Plugin]
            Il plugin, sviluppato da Julien Ponge e adottato semi-ufficialmente dai manutentori del progetto Vert.x, fornisce una configurazione del progetto ottimizzata per progetti Vert.x.
            Rende possibile il lancio dei verticle in modo indipendente e con la ricompilazione automatica, molto comodo in sede di sviluppo e debug.

          \item[Kotlin]
            Il plugin, realizzato in modo ufficiale da JetBrains, configura Gradle per la compilazione di codice Kotlin e la configurazione delle opzioni per la generazione del bytecode.

            Per motivi di compatibilità con il simulatore Alchemist, è stata scelta come versione target del bytecode Java 11.

          \item[Ktlint Gradle]
            Il plugin, realizzato da Jonathan Leitschuh, è un wrapper dello strumento di analisi statica di codice Kotlin \emph{ktlint}, realizzato da Pinterest.
            Si è scelto di utilizzare ktlint anziché \emph{detekt}, altro strumento simile, in quanto non richiede una configurazione personalizzata, bensì impone un insieme standard di regole, comunemente studiate e accettate dalla community.

          \item[refreshVersions]
            Il plugin, sviluppato da Jean-Michel Fayard, permette una migliore gestione delle dipendenze automatizzandone gli aggiornamenti.

          \item[JUnit]
            JUnit è uno dei più noti framework di unit testing per Java e linguaggi derivati.
            Il plugin, integrato ufficialmente in Gradle, permette l'esecuzione di test automatizzati con tale framework.

            In questo progetto è stata utilizzata la versione 5 di JUnit, utilizzando il motore di esecuzione \emph{jupiter}.
          \item[JaCoCo]
            JaCoCo è uno strumento per la misura della copertura del codice da parte dei test realizzati.
            Si integra con JUnit ed è pensato per Java e linguaggi derivati.
            Il plugin, integrato ufficialmente in Gradle, offre una dettagliata configurazione e permette la generazione di report in diversi formati.
        \end{description}

        Per lo sviluppo del codice è stato utilizzato l'ambiente di sviluppo integrato \emph{JetBrains Intellij IDEA} in versione \emph{Ultimate 2019.3.3}.
        Si è scelto questo rispetto ad altri IDE (come ad esempio Eclipse) in quanto in grado di offrire un'integrazione migliore con Gradle e Kotlin.

      \subsubsection{Frontend}

        % TODO

        % \subsection{Librerie esterne}
    % \subsection{Strumenti di sviluppo}
    %   In questa sezione verranno presentati tutti gli strumenti utilizzati per sviluppare il codice del sistema,
    %   descrivendone la loro utilità e il loro impiego.

    %   \subsubsection{Ambiente di sviluppo}
    %     Un IDE, o \emph{Integrated Development Environment} è un software che aiuta i programmatori nello sviluppo del codice sorgente di un software.\unsure{Non sono sicuro che questa parte sia necessaria}
    %     Esso mette a disposizione tutta una serie di strumenti e funzionalità utili per lo sviluppo e il debugging.
    %     Solitamente uno strumento di questo tipo mette a disposizione un editor di testo, un compilatore o un interprete (o entrambi) e un debugger.

    %     Per lo sviluppo di questo sistema sono stati utilizzati due IDE forniti da JetBrains: Intellij IDEA e WebStorm.
    %     In particolare,

  \section{Dettagli implementativi: Frontend}
  \section{Dettagli implementativi: Backend}
