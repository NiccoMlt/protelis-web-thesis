\chapter{Lavori futuri}\label{ch:future}

  Il lavoro realizzato per questa tesi si pone come punto di partenza per diverse possibili modifiche.

  In primo luogo, l'implementazione attuale si focalizza sulla \emph{simulazione} di una rete di dispositivi, ma rimane aperto ad altre alternative.
  Ad esempio, è possibile rimpiazzare Alchemist con un utilizzo di più basso livello degli strumenti offerti dal framework di Protelis, andando a definire una differente implementazione dell'interfaccia \texttt{ProtelisEngine}.
  \improvement{Dovrei inserire qualche dettaglio progettuale aggiuntivo?}
  Oppure, sarebbe possibile allacciare al sistema una rete fisica di dispositivi, utilizzando un verticle come \emph{bridge} tra il sistema e la rete.

  Per come è stata progettata l'architettura di questo prototipo, ciascuna di queste modifiche non richiede pesanti modifiche:
  in molti casi, la semplice aggiunta di un verticle sarebbe sufficiente.

  Un altro aspetto su cui sarebbe interessante porre l'attenzione in futuro sarebbe la scalabilità:
  come detto nella~\Cref{sec:arch:server}, il prototipo è stato realizzato con un architettura considerabile monolitica, ma il framework offre molte libertà.
  Vert.x permette infatti l'esecuzione di singoli verticle (ed eventuali dipendenze) in modo indipendente, realizzando, di fatto, dei microservizi.
  Esso offre inoltre il supporto a diversi strumenti per l'integrazione con tecnologie per il \emph{service discovery}, per lo scambio di messaggi e per il bilanciamento del carico.\improvement{Dovrei citare più nel dettaglio tali tecnologie?}

  Una soluzione interessante di deploy potrebbe vedere, ad esempio, diversi verticle pacchettizzati come container Docker ed eseguiti in una piattaforma basata su Kubernetes o OpenShift,
  delegando a quest'ultimo livello PaaS il deploy di repliche per l'incremento delle performance on-demand.

  Spostando l'attenzione sul client, potrebbe essere utile aumentare le possibilità di interazione con l'esecuzione.
  Potrebbe, ad esempio, risultare utile la possibilità di interagire con i nodi rappresentati, spostandoli e vedendo così l'esecuzione adattarsi alla perturbazione.
  Funzionalità di questo tipo possono essere inserite in modo abbastanza semplice tramite la realizzazione di eventi specifici, generati dai componenti React e inoltrati tramite SockJS verso il server.

  Infine, un ultimo approccio di miglioramento potrebbe coinvolgere il cambio di parte delle tecnologie impiegate.
  Per la realizzazione di questo prototipo si è ritenuto l'uso di TypeScript ottimale per le ragioni espresse nelle \Cref{subsec:ts,subsec:kotlinjs,subsub:ts},
  ma, potenzialmente, Kotlin potrebbe essere una soluzione molto interessante una volta che avrà raggiunto una stabilità accettabile per il target JS\@.
  Tale migrazione permettere una condivisione più efficiente delle componenti di modello condivise e potenzialmente delle dipendenze.
  Inoltre, collaborando con il team che mantiene il progetto Protelis, sarebbe potenzialmente possibile realizzare un'implementazione locale al client dell'interprete.
  In questo modo, il ruolo del server potrebbe diventare non più necessario per piccoli progetti a scopo educativo come quelli a cui questo progetto ha fatto riferimento fin dall'inizio.
